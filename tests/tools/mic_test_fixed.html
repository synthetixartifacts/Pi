<!DOCTYPE html>
<html>
<head>
    <title>Microphone Test - Enhanced</title>
    <style>
        body { 
            font-family: 'Courier New', monospace; 
            background: #000; 
            color: #0f0; 
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        button { 
            padding: 10px 20px;
            background: #003300;
            color: #0f0;
            border: 1px solid #0f0;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s;
        }
        button:hover:not(:disabled) {
            background: #004400;
            box-shadow: 0 0 10px #0f0;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            animation: pulse 2s infinite;
        }
        .status-active { background: #0f0; }
        .status-warning { background: #ff0; }
        .status-error { background: #f00; }
        .status-inactive { background: #333; animation: none; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #meter { 
            width: 100%; 
            height: 40px; 
            background: #111; 
            margin: 20px 0;
            border: 1px solid #333;
            position: relative;
            overflow: hidden;
        }
        #level { 
            height: 100%; 
            background: linear-gradient(to right, #0f0, #ff0, #f00); 
            width: 0%;
            transition: width 0.1s;
        }
        #peak-indicator {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: #fff;
            transition: left 0.5s;
        }
        pre { 
            background: #111; 
            padding: 15px; 
            border: 1px solid #333;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        .error { color: #f00; }
        .warning { color: #ff0; }
        .success { color: #0f0; }
        .info { color: #0af; }
        
        #waveform-container {
            background: #111;
            border: 1px solid #333;
            padding: 10px;
            margin: 20px 0;
        }
        #waveform {
            width: 100%;
            height: 100px;
        }
        
        .diagnostics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .diagnostic-card {
            background: #111;
            border: 1px solid #333;
            padding: 15px;
        }
        .diagnostic-card h3 {
            margin-top: 0;
            color: #0af;
        }
        .diagnostic-value {
            font-size: 24px;
            font-weight: bold;
        }
        #silence-timer {
            background: #220000;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #f00;
            display: none;
        }
        #silence-timer.active {
            display: block;
        }
    </style>
</head>
<body>
    <h1>üé§ Enhanced Microphone Test & Diagnostics</h1>
    
    <div class="controls">
        <button id="start">Start Microphone Test</button>
        <button id="stop" disabled>Stop</button>
        <button id="refresh-devices">Refresh Devices</button>
        <button id="download-recording" disabled>Download Recording</button>
        <button id="test-silence-recovery">Test Silence Recovery</button>
    </div>
    
    <div>
        <span id="status" class="status-indicator status-inactive"></span>
        <span id="status-text">Ready to start...</span>
    </div>
    
    <div id="silence-timer" class="warning">
        ‚ö†Ô∏è Silence detected for <span id="silence-duration">0</span> seconds. 
        Attempting recovery in <span id="recovery-countdown">5</span>...
    </div>
    
    <div id="meter">
        <div id="level"></div>
        <div id="peak-indicator" style="left: 0"></div>
    </div>
    
    <div id="waveform-container">
        <canvas id="waveform"></canvas>
    </div>
    
    <div class="diagnostics">
        <div class="diagnostic-card">
            <h3>Current Level</h3>
            <div class="diagnostic-value" id="current-level">0 dB</div>
        </div>
        <div class="diagnostic-card">
            <h3>Peak Level</h3>
            <div class="diagnostic-value" id="peak-level">0 dB</div>
        </div>
        <div class="diagnostic-card">
            <h3>Avg Level (5s)</h3>
            <div class="diagnostic-value" id="avg-level">0 dB</div>
        </div>
        <div class="diagnostic-card">
            <h3>Silence Duration</h3>
            <div class="diagnostic-value" id="silence-stat">0s</div>
        </div>
    </div>
    
    <pre id="info">System ready. Click "Start Microphone Test" to begin...</pre>
    
    <h2>Device Information</h2>
    <pre id="device-info">Scanning devices...</pre>
    
    <h2>Debug Log</h2>
    <pre id="debug-log" style="max-height: 300px; overflow-y: auto;"></pre>

    <script>
        // Global state management
        const state = {
            stream: null,
            audioContext: null,
            analyser: null,
            dataArray: null,
            animationId: null,
            mediaRecorder: null,
            recordedChunks: [],
            silenceStartTime: null,
            lastAudioTime: Date.now(),
            peakLevel: 0,
            levelHistory: [],
            isRecovering: false,
            recoveryAttempts: 0,
            maxRecoveryAttempts: 3
        };
        
        // Configuration
        const config = {
            silenceThreshold: -50, // dB
            silenceTimeout: 3000, // ms before considering silence an issue
            recoveryDelay: 5000, // ms before attempting recovery
            levelHistorySize: 50,
            minNoiseLevel: 0.01
        };
        
        // Utility functions
        function log(message, type = 'info') {
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            const logEl = document.getElementById('debug-log');
            const entry = `[${timestamp}] ${type.toUpperCase()}: ${message}\n`;
            logEl.textContent = entry + logEl.textContent;
            
            // Keep log size manageable
            const lines = logEl.textContent.split('\n');
            if (lines.length > 100) {
                logEl.textContent = lines.slice(0, 100).join('\n');
            }
        }
        
        function updateStatus(status, message) {
            const statusEl = document.getElementById('status');
            const statusTextEl = document.getElementById('status-text');
            
            statusEl.className = 'status-indicator';
            switch(status) {
                case 'active':
                    statusEl.classList.add('status-active');
                    break;
                case 'warning':
                    statusEl.classList.add('status-warning');
                    break;
                case 'error':
                    statusEl.classList.add('status-error');
                    break;
                default:
                    statusEl.classList.add('status-inactive');
            }
            
            statusTextEl.textContent = message;
        }
        
        function convertToDb(value) {
            if (value === 0) return -Infinity;
            return 20 * Math.log10(value);
        }
        
        async function enumerateDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                
                let deviceInfo = 'Available Audio Input Devices:\n';
                deviceInfo += '=' .repeat(50) + '\n';
                
                audioInputs.forEach((device, index) => {
                    deviceInfo += `\nDevice ${index + 1}:\n`;
                    deviceInfo += `  Label: ${device.label || 'Unnamed Device'}\n`;
                    deviceInfo += `  ID: ${device.deviceId}\n`;
                    deviceInfo += `  Group: ${device.groupId}\n`;
                });
                
                if (audioInputs.length === 0) {
                    deviceInfo += '\n‚ö†Ô∏è No audio input devices found!\n';
                    deviceInfo += 'Please check:\n';
                    deviceInfo += '  - Microphone is connected\n';
                    deviceInfo += '  - Browser has permission to access microphone\n';
                    deviceInfo += '  - Audio drivers are installed\n';
                }
                
                document.getElementById('device-info').textContent = deviceInfo;
                log(`Found ${audioInputs.length} audio input devices`);
                
                return audioInputs;
            } catch (err) {
                log(`Error enumerating devices: ${err.message}`, 'error');
                return [];
            }
        }
        
        async function requestMicrophone() {
            try {
                log('Requesting microphone access...');
                updateStatus('warning', 'Requesting microphone permission...');
                
                // Try multiple constraint combinations for better compatibility
                const constraints = [
                    {
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    },
                    {
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    },
                    {
                        audio: true
                    }
                ];
                
                let stream = null;
                let successfulConstraints = null;
                
                for (const constraint of constraints) {
                    try {
                        log(`Trying constraints: ${JSON.stringify(constraint.audio)}`);
                        stream = await navigator.mediaDevices.getUserMedia(constraint);
                        successfulConstraints = constraint;
                        break;
                    } catch (err) {
                        log(`Failed with constraints: ${err.message}`, 'warning');
                    }
                }
                
                if (!stream) {
                    throw new Error('Could not access microphone with any constraint combination');
                }
                
                log(`Successfully got stream with constraints: ${JSON.stringify(successfulConstraints.audio)}`, 'success');
                return stream;
                
            } catch (err) {
                log(`Microphone access failed: ${err.message}`, 'error');
                
                // Provide helpful error messages
                if (err.name === 'NotAllowedError') {
                    throw new Error('Microphone permission denied. Please allow microphone access and try again.');
                } else if (err.name === 'NotFoundError') {
                    throw new Error('No microphone found. Please connect a microphone and try again.');
                } else if (err.name === 'NotReadableError') {
                    throw new Error('Microphone is in use by another application. Please close other apps using the microphone.');
                } else {
                    throw err;
                }
            }
        }
        
        function cleanupResources() {
            log('Cleaning up resources...');
            
            // Stop animation
            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
                state.animationId = null;
            }
            
            // Stop recording
            if (state.mediaRecorder && state.mediaRecorder.state !== 'inactive') {
                state.mediaRecorder.stop();
            }
            
            // Close audio context
            if (state.audioContext && state.audioContext.state !== 'closed') {
                state.audioContext.close();
                state.audioContext = null;
            }
            
            // Stop all tracks
            if (state.stream) {
                state.stream.getTracks().forEach(track => {
                    track.stop();
                    log(`Stopped track: ${track.kind} - ${track.label}`);
                });
                state.stream = null;
            }
            
            // Clear arrays
            state.dataArray = null;
            state.analyser = null;
            state.levelHistory = [];
            
            log('Cleanup complete', 'success');
        }
        
        function detectSilence(level) {
            const levelDb = convertToDb(level);
            const now = Date.now();
            
            if (levelDb < config.silenceThreshold) {
                if (!state.silenceStartTime) {
                    state.silenceStartTime = now;
                    log(`Silence detected (level: ${levelDb.toFixed(1)} dB)`);
                }
                
                const silenceDuration = now - state.silenceStartTime;
                document.getElementById('silence-stat').textContent = `${(silenceDuration / 1000).toFixed(1)}s`;
                
                if (silenceDuration > config.silenceTimeout && !state.isRecovering) {
                    handleSilenceTimeout(silenceDuration);
                }
            } else {
                if (state.silenceStartTime) {
                    const duration = now - state.silenceStartTime;
                    log(`Audio resumed after ${(duration / 1000).toFixed(1)}s of silence`);
                    state.silenceStartTime = null;
                    document.getElementById('silence-stat').textContent = '0s';
                    hideSilenceWarning();
                }
                state.lastAudioTime = now;
            }
        }
        
        function handleSilenceTimeout(duration) {
            log(`Extended silence detected: ${(duration / 1000).toFixed(1)}s`, 'warning');
            updateStatus('warning', `Silence detected for ${(duration / 1000).toFixed(1)}s`);
            
            const silenceTimer = document.getElementById('silence-timer');
            silenceTimer.classList.add('active');
            document.getElementById('silence-duration').textContent = (duration / 1000).toFixed(1);
            
            // Start countdown for recovery
            let countdown = 5;
            const countdownInterval = setInterval(() => {
                countdown--;
                document.getElementById('recovery-countdown').textContent = countdown;
                
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    attemptRecovery();
                }
            }, 1000);
            
            // Store interval ID for cleanup
            state.countdownInterval = countdownInterval;
        }
        
        function hideSilenceWarning() {
            const silenceTimer = document.getElementById('silence-timer');
            silenceTimer.classList.remove('active');
            
            if (state.countdownInterval) {
                clearInterval(state.countdownInterval);
                state.countdownInterval = null;
            }
        }
        
        async function attemptRecovery() {
            if (state.isRecovering) {
                log('Recovery already in progress', 'warning');
                return;
            }
            
            state.isRecovering = true;
            state.recoveryAttempts++;
            
            log(`Attempting recovery (attempt ${state.recoveryAttempts}/${config.maxRecoveryAttempts})...`, 'warning');
            updateStatus('warning', `Attempting recovery (${state.recoveryAttempts}/${config.maxRecoveryAttempts})...`);
            
            try {
                // Clean up existing resources
                cleanupResources();
                
                // Wait a moment
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Try to reinitialize
                await startMicrophone();
                
                log('Recovery successful!', 'success');
                updateStatus('active', 'Recovery successful - Microphone active');
                state.recoveryAttempts = 0;
                
            } catch (err) {
                log(`Recovery failed: ${err.message}`, 'error');
                
                if (state.recoveryAttempts >= config.maxRecoveryAttempts) {
                    updateStatus('error', 'Maximum recovery attempts reached. Please refresh the page.');
                    document.getElementById('start').disabled = false;
                    document.getElementById('stop').disabled = true;
                } else {
                    // Try again after delay
                    setTimeout(() => attemptRecovery(), config.recoveryDelay);
                }
            } finally {
                state.isRecovering = false;
                hideSilenceWarning();
            }
        }
        
        async function startMicrophone() {
            try {
                // Get microphone stream
                state.stream = await requestMicrophone();
                
                // Get track information
                const track = state.stream.getAudioTracks()[0];
                const settings = track.getSettings();
                const capabilities = track.getCapabilities ? track.getCapabilities() : {};
                
                // Display settings
                const info = `Microphone Active!\n
Settings:
- Device: ${track.label}
- Sample Rate: ${settings.sampleRate || 'default'} Hz
- Echo Cancellation: ${settings.echoCancellation}
- Noise Suppression: ${settings.noiseSuppression}
- Auto Gain Control: ${settings.autoGainControl}
- Channel Count: ${settings.channelCount || 'default'}

Capabilities:
- Sample Rate Range: ${capabilities.sampleRate ? `${capabilities.sampleRate.min}-${capabilities.sampleRate.max}` : 'N/A'}
- Echo Cancellation: ${capabilities.echoCancellation || 'N/A'}
- Noise Suppression: ${capabilities.noiseSuppression || 'N/A'}

Speak into your microphone to see the levels!`;
                
                document.getElementById('info').textContent = info;
                
                // Setup audio analysis
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                state.analyser = state.audioContext.createAnalyser();
                const source = state.audioContext.createMediaStreamSource(state.stream);
                source.connect(state.analyser);
                
                state.analyser.fftSize = 2048;
                const bufferLength = state.analyser.frequencyBinCount;
                state.dataArray = new Uint8Array(bufferLength);
                
                // Setup recording
                setupRecording();
                
                // Start visualization
                visualize();
                
                // Update UI
                updateStatus('active', 'Microphone active and monitoring');
                document.getElementById('start').disabled = true;
                document.getElementById('stop').disabled = false;
                document.getElementById('download-recording').disabled = false;
                
                log('Microphone started successfully', 'success');
                
            } catch (err) {
                log(`Failed to start microphone: ${err.message}`, 'error');
                updateStatus('error', err.message);
                document.getElementById('info').textContent = `Error: ${err.message}\n\nPlease check:\n1. Microphone is connected\n2. Browser has permission\n3. No other app is using the microphone`;
                throw err;
            }
        }
        
        function setupRecording() {
            if (!state.stream) return;
            
            try {
                const mimeType = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/ogg';
                state.mediaRecorder = new MediaRecorder(state.stream, { mimeType });
                state.recordedChunks = [];
                
                state.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        state.recordedChunks.push(event.data);
                    }
                };
                
                state.mediaRecorder.start(100); // Collect data every 100ms
                log(`Recording started (${mimeType})`, 'success');
            } catch (err) {
                log(`Failed to setup recording: ${err.message}`, 'warning');
            }
        }
        
        function visualize() {
            if (!state.analyser) return;
            
            state.analyser.getByteFrequencyData(state.dataArray);
            
            // Calculate RMS level
            let sum = 0;
            for (let i = 0; i < state.dataArray.length; i++) {
                sum += state.dataArray[i] * state.dataArray[i];
            }
            const rms = Math.sqrt(sum / state.dataArray.length) / 255;
            
            // Update level meter
            const percentage = Math.min(100, rms * 200);
            document.getElementById('level').style.width = percentage + '%';
            
            // Track peak
            if (rms > state.peakLevel) {
                state.peakLevel = rms;
                document.getElementById('peak-indicator').style.left = percentage + '%';
            }
            
            // Update history for averaging
            state.levelHistory.push(rms);
            if (state.levelHistory.length > config.levelHistorySize) {
                state.levelHistory.shift();
            }
            
            // Calculate average
            const avgLevel = state.levelHistory.reduce((a, b) => a + b, 0) / state.levelHistory.length;
            
            // Update displays
            const currentDb = convertToDb(rms);
            const peakDb = convertToDb(state.peakLevel);
            const avgDb = convertToDb(avgLevel);
            
            document.getElementById('current-level').textContent = 
                isFinite(currentDb) ? `${currentDb.toFixed(1)} dB` : '-‚àû dB';
            document.getElementById('peak-level').textContent = 
                isFinite(peakDb) ? `${peakDb.toFixed(1)} dB` : '-‚àû dB';
            document.getElementById('avg-level').textContent = 
                isFinite(avgDb) ? `${avgDb.toFixed(1)} dB` : '-‚àû dB';
            
            // Draw waveform
            drawWaveform();
            
            // Check for silence
            detectSilence(rms);
            
            // Continue animation
            state.animationId = requestAnimationFrame(visualize);
        }
        
        function drawWaveform() {
            const canvas = document.getElementById('waveform');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size if needed
            if (canvas.width !== canvas.offsetWidth) {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!state.analyser) return;
            
            // Get time domain data
            const bufferLength = state.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            state.analyser.getByteTimeDomainData(dataArray);
            
            // Draw waveform
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#0f0';
            ctx.beginPath();
            
            const sliceWidth = canvas.width / bufferLength;
            let x = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * canvas.height / 2;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            ctx.stroke();
        }
        
        // Event handlers
        document.getElementById('start').onclick = async () => {
            try {
                await startMicrophone();
            } catch (err) {
                // Error already handled in startMicrophone
            }
        };
        
        document.getElementById('stop').onclick = () => {
            log('Stopping microphone...');
            cleanupResources();
            
            // Reset UI
            document.getElementById('level').style.width = '0%';
            document.getElementById('info').textContent = 'Microphone stopped.';
            document.getElementById('start').disabled = false;
            document.getElementById('stop').disabled = true;
            document.getElementById('download-recording').disabled = true;
            updateStatus('inactive', 'Microphone stopped');
            
            // Reset state
            state.peakLevel = 0;
            state.silenceStartTime = null;
            state.recoveryAttempts = 0;
            hideSilenceWarning();
        };
        
        document.getElementById('refresh-devices').onclick = async () => {
            log('Refreshing device list...');
            await enumerateDevices();
        };
        
        document.getElementById('download-recording').onclick = () => {
            if (state.recordedChunks.length === 0) {
                log('No recording available', 'warning');
                return;
            }
            
            const blob = new Blob(state.recordedChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `microphone-test-${new Date().toISOString()}.webm`;
            a.click();
            URL.revokeObjectURL(url);
            
            log(`Downloaded recording (${(blob.size / 1024).toFixed(2)} KB)`, 'success');
        };
        
        document.getElementById('test-silence-recovery').onclick = () => {
            log('Testing silence recovery mechanism...', 'warning');
            
            // Simulate silence
            if (state.stream) {
                state.silenceStartTime = Date.now() - config.silenceTimeout - 1000;
                updateStatus('warning', 'Simulating silence condition...');
            } else {
                log('Start microphone first to test recovery', 'warning');
            }
        };
        
        // Initialize on page load
        window.addEventListener('load', async () => {
            log('Page loaded, initializing...');
            
            // Check browser compatibility
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                const msg = 'Your browser does not support audio recording. Please use Chrome, Firefox, or Edge.';
                log(msg, 'error');
                document.getElementById('info').textContent = msg;
                document.getElementById('start').disabled = true;
                return;
            }
            
            // Enumerate devices
            await enumerateDevices();
            
            // Monitor device changes
            navigator.mediaDevices.addEventListener('devicechange', async () => {
                log('Device change detected');
                await enumerateDevices();
            });
            
            log('Initialization complete', 'success');
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            cleanupResources();
        });
        
        // Handle visibility changes to pause/resume
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && state.stream) {
                log('Page hidden, pausing analysis', 'info');
                if (state.animationId) {
                    cancelAnimationFrame(state.animationId);
                    state.animationId = null;
                }
            } else if (!document.hidden && state.stream && !state.animationId) {
                log('Page visible, resuming analysis', 'info');
                visualize();
            }
        });
    </script>
</body>
</html>